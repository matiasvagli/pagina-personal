export interface NotaTecnica {
  titulo: string;
  fecha: string;
  resumen: string;
  contenido: string;
  tags: string[];
  url: string;
}

export const notasTecnicas: NotaTecnica[] = [
  {
    titulo: "El Error Que Siempre Cometemos: Modelando Relaciones Muchos-a-Muchos con Atributos (Pedido + Producto)",
    fecha: "Oct 2025",
    resumen: "En bases de datos y ORMs como Django, las relaciones Muchos-a-Muchos con datos extra (como cantidad o precio) no se resuelven con la configuraci√≥n por defecto. La soluci√≥n es siempre crear una tabla intermedia que act√∫e como 'rompe-relaciones' y guarde esos atributos clave, garantizando consultas limpias y performance optimizada.",
    contenido: `
      <h2>ü§¶‚Äç‚ôÄÔ∏è El Problema Real: Pedidos con Productos y el Factor "Cantidad"</h2>
      <p>Si est√°s construyendo una aplicaci√≥n de e-commerce, un sistema de gesti√≥n o cualquier cosa que implique transacciones, tarde o temprano te encuentras con la relaci√≥n Muchos-a-Muchos con atributos.</p>
      
      <p>El caso m√°s com√∫n es la relaci√≥n entre Pedido y Producto. Un pedido puede tener muchos productos, y un producto puede estar en muchos pedidos. ¬°F√°cil! Pero el negocio exige detalles:</p>
      
      <ul>
        <li>‚úÖ ¬øCu√°nta Cantidad de ese producto se pidi√≥?</li>
        <li>‚úÖ ¬øCu√°l era el Precio Unitario en ese momento del pedido (pueden cambiar)?</li>
        <li>‚úÖ Necesidad de calcular el Subtotal y el Total</li>
      </ul>

      <h3>üéØ El Objetivo de la Consulta (Lo que el negocio pide)</h3>
      <p>Queremos pedirle a la base de datos una factura completa y detallada, algo as√≠ como:</p>
      <blockquote>"Dame el Pedido 1056 con cada producto, su cantidad, el precio de venta y el subtotal de esa l√≠nea."</blockquote>
      
      <table>
        <thead>
          <tr>
            <th>Producto</th>
            <th>Cantidad</th>
            <th>Precio Unitario</th>
            <th>Subtotal</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Maple 30 huevos</td>
            <td>5</td>
            <td>$1200</td>
            <td>$6000</td>
          </tr>
          <tr>
            <td>Caj√≥n 15kg</td>
            <td>2</td>
            <td>$9500</td>
            <td>$19000</td>
          </tr>
          <tr>
            <td>Bandeja</td>
            <td>10</td>
            <td>$300</td>
            <td>$3000</td>
          </tr>
        </tbody>
      </table>

      <h3>‚ùå El Modelo Incorrecto: El "Anti-Patr√≥n" de la Lista de IDs</h3>
      <p>El error cl√°sico, especialmente en la fase inicial, es intentar almacenar una lista de IDs en una columna del Pedido, pensando en la simplicidad:</p>
      
      <pre><code>CREATE TABLE pedidos (
  id SERIAL PRIMARY KEY,
  fecha TIMESTAMP,
  productos TEXT  -- ‚ùå ¬°Grave error! Ejemplo: "1,5,7"
);</code></pre>

      <table>
        <thead>
          <tr>
            <th>Problema</th>
            <th>Motivo por el que esto rompe el proyecto</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>No hay atributos</td>
            <td>No puedo saber cu√°ntos productos se vendieron (Cantidad) ni a qu√© precio.</td>
          </tr>
          <tr>
            <td>Imposible hacer JOIN</td>
            <td>La base de datos no puede cruzar TEXT con IDs de otras tablas.</td>
          </tr>
          <tr>
            <td>Consulta in√∫til</td>
            <td>Tienes que parsear strings y hacer l√≥gica de negocio en la aplicaci√≥n, no en la DB.</td>
          </tr>
          <tr>
            <td>Anti patr√≥n</td>
            <td>No es escalable, no tiene integridad referencial y es imposible de auditar.</td>
          </tr>
        </tbody>
      </table>

      <h3>‚úÖ El Modelo Correcto: La Tabla Intermedia (El Detalle)</h3>
      <p>La soluci√≥n profesional, que respeta el principio de bases de datos relacionales, es introducir una tabla intermedia, la cual se convierte en la due√±a de los atributos que dependen de ambas entidades. En este caso, la llamamos detalle_pedido.</p>

      <h4>SQL Puro: Rompiendo la Relaci√≥n Muchos-a-Muchos</h4>
      <p>Esta tabla es la que lleva la carga de los atributos (cantidad y precio_unitario).</p>

      <pre><code>CREATE TABLE detalle_pedido (
  id SERIAL PRIMARY KEY,
  -- Foreign Keys (Llaves for√°neas que rompen la relaci√≥n)
  pedido_id INT REFERENCES pedidos(id),
  producto_id INT REFERENCES productos(id),
  -- Atributos de la relaci√≥n
  cantidad INT NOT NULL,
  precio_unitario NUMERIC(10,2) NOT NULL
);

-- ‚ú® Opcional pero recomendado: Garantizar que un producto no se repita
-- ALTER TABLE detalle_pedido ADD CONSTRAINT detalle_unico 
-- UNIQUE (pedido_id, producto_id);</code></pre>

      <p>Ahora, la consulta es limpia, performante y se resuelve completamente en la base de datos (DB):</p>
      <pre><code>SELECT p.nombre, d.cantidad, d.precio_unitario,
       -- ¬°C√°lculo en la DB!
       (d.cantidad * d.precio_unitario) AS subtotal
FROM detalle_pedido d
JOIN productos p ON d.producto_id = p.id
WHERE d.pedido_id = 1056;</code></pre>

      <h3>üêç Traducci√≥n a Django ORM: Usando through</h3>
      <p>El error m√°s com√∫n en Django es usar el ManyToManyField directamente, que no permite almacenar la cantidad ni el precio:</p>

      <pre><code>class Pedido(models.Model):
    # productos = models.ManyToManyField(Producto)  # ‚ùå ERROR CL√ÅSICO
    pass</code></pre>

      <h4>El Modelo Correcto con through</h4>
      <p>La clave es definir la tabla intermedia (DetallePedido) como un modelo Django expl√≠cito, y luego indicarle al ManyToManyField que use ese modelo intermedio con el argumento through.</p>

      <pre><code>class Producto(models.Model):
    nombre = models.CharField(max_length=100)
    precio_base = models.DecimalField(max_digits=10, decimal_places=2)

class Pedido(models.Model):
    fecha = models.DateTimeField(auto_now_add=True)
    # ‚úÖ Le indicamos a Django que use nuestro modelo intermedio:
    productos = models.ManyToManyField(Producto, through='DetallePedido')

class DetallePedido(models.Model):
    # Foreign Keys expl√≠citas:
    pedido = models.ForeignKey(Pedido, on_delete=models.CASCADE, related_name="detalles")
    producto = models.ForeignKey(Producto, on_delete=models.CASCADE)
    # Atributos de la relaci√≥n:
    cantidad = models.PositiveIntegerField()
    precio_unitario = models.DecimalField(max_digits=10, decimal_places=2)

    @property
    def subtotal(self):
        # La l√≥gica de c√°lculo queda encapsulada en el modelo
        return self.cantidad * self.precio_unitario</code></pre>

      <h3>üöÄ Optimizaci√≥n de Rendimiento (prefetch_related)</h3>
      <p>Una vez modelado correctamente, hay que consultarlo bien. Si iteramos sobre los productos sin cuidado, Django podr√≠a generar la famosa N+1 query. Usamos prefetch_related para evitarla y traer toda la informaci√≥n con el m√≠nimo de consultas.</p>

      <pre><code># Consulta optimizada: trae el pedido, sus detalles y los productos 
# relacionados en muy pocas queries.
pedido = Pedido.objects.prefetch_related("detalles__producto").get(id=1056)

# Iteraci√≥n limpia y eficiente:
for item in pedido.detalles.all():
    # Accedemos a los atributos del Detalle (cantidad, subtotal)
    print(
        item.producto.nombre,    # Nombre del producto (relacionado)
        item.cantidad,           # Cantidad (atributo del Detalle)
        item.subtotal            # Subtotal (propiedad del Detalle)
    )</code></pre>

      <h3>üõ†Ô∏è Regla de Backend Profesional</h3>
      <p>Si en una relaci√≥n Muchos-a-Muchos necesitas guardar cualquier dato extra (cantidad, precio, fecha de asociaci√≥n, estado), debes abandonar el ManyToMany autom√°tico y crear una tabla intermedia expl√≠cita.</p>
      
      <p>Este patr√≥n te garantiza integridad referencial, consultas SQL limpias y la base para escalar tu aplicaci√≥n.</p>

      <table>
        <thead>
          <tr>
            <th>Incorrecto ‚ùå</th>
            <th>Correcto ‚úÖ</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>ManyToManyField directo</td>
            <td>Modelo intermedio con through</td>
          </tr>
          <tr>
            <td>No se puede calcular subtotales</td>
            <td>Consultas limpias y √∫tiles con JOIN</td>
          </tr>
          <tr>
            <td>Mal rendimiento (N+1 queries)</td>
            <td>Optimizaci√≥n con prefetch_related</td>
          </tr>
          <tr>
            <td>Cero escalabilidad</td>
            <td>Se pueden agregar descuentos, impuestos, etc.</td>
          </tr>
        </tbody>
      </table>

      <h3>Tech Stack</h3>
      <ul>
        <li><strong>Concepto:</strong> Bases de Datos Relacionales, Modelado</li>
        <li><strong>SQL:</strong> JOIN, REFERENCES</li>
        <li><strong>ORM:</strong> Django ManyToManyField, through, prefetch_related</li>
      </ul>
      <h2>El problema real: pedidos con productos</h2>
      <p>En el mundo real, cuando empezamos a construir aplicaciones con bases de datos relacionales, tarde o temprano aparece esta situaci√≥n: una relaci√≥n muchos-a-muchos necesita informaci√≥n adicional.</p>
      
      <p>El ejemplo m√°s com√∫n es un <strong>Pedido con Productos</strong>: un pedido puede tener muchos productos y cada producto puede estar en muchos pedidos. Hasta ah√≠ parece simple. Pero la realidad del negocio agrega detalles:</p>
      
      <ul>
        <li>‚úÖ Cada producto tiene cantidad</li>
        <li>‚úÖ Cada producto puede tener un precio distinto para ese pedido</li>
        <li>‚úÖ Y necesitamos calcular subtotal y total</li>
      </ul>

      <h3>üéØ Qu√© queremos consultar (objetivo real)</h3>
      <p>Queremos poder pedirle a la base de datos algo as√≠:</p>
      <blockquote>"Dame el pedido 1056 con todos sus productos, cantidades y subtotales"</blockquote>
      
      <p><strong>Resultado esperado:</strong></p>
      <table>
        <thead>
          <tr>
            <th>Producto</th>
            <th>Cantidad</th>
            <th>Precio Unitario</th>
            <th>Subtotal</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Maple 30 huevos</td>
            <td>5</td>
            <td>1200</td>
            <td>6000</td>
          </tr>
          <tr>
            <td>Caj√≥n 15kg</td>
            <td>2</td>
            <td>9500</td>
            <td>19000</td>
          </tr>
          <tr>
            <td>Bandeja</td>
            <td>10</td>
            <td>300</td>
            <td>3000</td>
          </tr>
        </tbody>
      </table>

      <h3>‚ùå Modelo incorrecto (el error cl√°sico)</h3>
      <p>Muchos modelan mal el pedido usando una columna lista con ids:</p>
      
      <pre><code>CREATE TABLE pedidos (
  id SERIAL PRIMARY KEY,
  fecha TIMESTAMP,
  productos TEXT  -- ejemplo: "1,5,7"
);</code></pre>

      <p>Y despu√©s intentan consultar as√≠:</p>
      <pre><code>SELECT productos FROM pedidos WHERE id = 1056;</code></pre>

      <p><strong>Salida:</strong> <code>"1,5,7"</code></p>

      <h4>¬øPor qu√© esto est√° mal?</h4>
      <table>
        <thead>
          <tr>
            <th>Problema</th>
            <th>Motivo</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>No hay cantidades</td>
            <td>No puedo saber cu√°ntos productos se vendieron</td>
          </tr>
          <tr>
            <td>No hay precios</td>
            <td>No puedo calcular nada</td>
          </tr>
          <tr>
            <td>No puedo hacer JOIN</td>
            <td>No puedo unir con tabla de productos</td>
          </tr>
          <tr>
            <td>Consulta in√∫til</td>
            <td>Tengo que parsear strings üòµ</td>
          </tr>
          <tr>
            <td>Anti patr√≥n</td>
            <td>No sirve para producci√≥n</td>
          </tr>
        </tbody>
      </table>

      <h3>‚úÖ Modelo correcto (relaci√≥n muchos-a-muchos con atributos)</h3>
      <p>La soluci√≥n profesional es crear una tabla intermedia que represente el detalle del pedido.</p>

      <pre><code>CREATE TABLE detalle_pedido (
  id SERIAL PRIMARY KEY,
  pedido_id INT REFERENCES pedidos(id),
  producto_id INT REFERENCES productos(id),
  cantidad INT NOT NULL,
  precio_unitario NUMERIC(10,2) NOT NULL
);</code></pre>

      <p>Ahora s√≠ podemos consultar correctamente:</p>
      <pre><code>SELECT p.nombre, d.cantidad, d.precio_unitario,
       (d.cantidad * d.precio_unitario) AS subtotal
FROM detalle_pedido d
JOIN productos p ON d.producto_id = p.id
WHERE d.pedido_id = 1056;</code></pre>

      <h3>üêç Django ORM: error t√≠pico</h3>
      <p>Muchos intentan esto al principio:</p>
      <pre><code>class Pedido(models.Model):
    productos = models.ManyToManyField(Producto)  # ‚ùå MAL</code></pre>

      <p><strong>Problema:</strong> no hay lugar para guardar cantidad ni precio. El proyecto despu√©s se rompe.</p>

      <h3>‚úÖ Django ORM: modelo correcto con through</h3>
      <pre><code>class Pedido(models.Model):
    fecha = models.DateTimeField(auto_now_add=True)

class Producto(models.Model):
    nombre = models.CharField(max_length=100)
    precio_base = models.DecimalField(max_digits=10, decimal_places=2)

class DetallePedido(models.Model):
    pedido = models.ForeignKey(Pedido, on_delete=models.CASCADE, related_name="detalles")
    producto = models.ForeignKey(Producto, on_delete=models.CASCADE)
    cantidad = models.PositiveIntegerField()
    precio_unitario = models.DecimalField(max_digits=10, decimal_places=2)

    @property
    def subtotal(self):
        return self.cantidad * self.precio_unitario</code></pre>

      <h3>üöÄ Consulta optimizada en Django (prefetch_related)</h3>
      <pre><code>pedido = Pedido.objects.prefetch_related("detalles__producto").get(id=1056)

for item in pedido.detalles.all():
    print(item.producto.nombre, item.cantidad, item.subtotal)</code></pre>

      <h3>‚úÖ ¬øPor qu√© va as√≠?</h3>
      <ul>
        <li><strong>through:</strong> permite definir modelo intermedio con atributos</li>
        <li><strong>prefetch_related:</strong> evita N+1 queries y mejora performance</li>
      </ul>

      <h3>üìä Comparaci√≥n final</h3>
      <table>
        <thead>
          <tr>
            <th>Incorrecto ‚ùå</th>
            <th>Correcto ‚úÖ</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>ManyToManyField directo</td>
            <td>Modelo intermedio con through</td>
          </tr>
          <tr>
            <td>No se puede consultar bien</td>
            <td>Consultas limpias y √∫tiles</td>
          </tr>
          <tr>
            <td>No escala</td>
            <td>Se puede agregar descuentos, impuestos, etc</td>
          </tr>
          <tr>
            <td>Mal rendimiento</td>
            <td>Optimizaci√≥n con prefetch_related</td>
          </tr>
        </tbody>
      </table>

      <blockquote>
        <p><strong>üîß Regla de backend real:</strong></p>
        <p>Si en una relaci√≥n muchos-a-muchos hay datos extra, siempre us√° una tabla intermedia.</p>
      </blockquote>
    `,
    tags: ["Django", "Bases de Datos", "ORM", "Modelado", "SQL"],
    url: "/notas/como-modelar-correctamente-relacion-muchos-a-muchos-con-atributos"
  },
  {
    titulo: "Docker para backenders: setup profesional con Django + Postgres",
    fecha: "Oct 2025",
    resumen: "Gu√≠a clara para containerizar backends Django con PostgreSQL usando buenas pr√°cticas profesionales.",
    contenido: `
      <h2>El problema real: "funciona en mi m√°quina"</h2>
      <p>Cuando trabajamos en backend, una de las partes m√°s dif√≠ciles no es escribir c√≥digo: es hacerlo funcionar igual en todos lados. Que funcione en tu m√°quina est√° bien, pero no sirve si falla cuando lo sub√≠s al servidor o cuando lo quiere probar otro dev.</p>
      
      <p>Ah√≠ entra <strong>Docker</strong>. Docker permite empaquetar tu backend con todas sus dependencias, para que se ejecute igual en desarrollo y producci√≥n. Es decir: <em>si corre en tu contenedor, corre en cualquier parte</em>.</p>

      <p>En esta gu√≠a vamos a ver c√≥mo usar Docker de forma clara y profesional para un backend real con Django + Postgres, usando buenas pr√°cticas de backend moderno.</p>

      <h3>üéØ ¬øQu√© vamos a construir?</h3>
      <p>Un backend real para un <strong>Sistema de Gesti√≥n de Ventas</strong> con:</p>
      <ul>
        <li>‚úÖ Backend: Django</li>
        <li>‚úÖ Base de datos: PostgreSQL</li>
        <li>‚úÖ Servicios levantados con docker-compose</li>
        <li>‚úÖ Vol√∫menes para persistencia de datos</li>
        <li>‚úÖ Variables de entorno .env</li>
        <li>‚úÖ Dockerfile para desarrollo y producci√≥n</li>
      </ul>

      <h3>1. Dockerfile b√°sico (modo desarrollo)</h3>
      <p>El Dockerfile define c√≥mo construir el contenedor de tu backend.</p>
      
      <h4>Opci√≥n A: Debian Slim (recomendada para desarrollo)</h4>
      <pre><code># Usar imagen oficial de Python 3.11 (versi√≥n slim para menor tama√±o)
FROM python:3.11-slim

# Establecer directorio de trabajo dentro del contenedor
WORKDIR /app

# Instalar dependencias del sistema (cliente PostgreSQL)
RUN apt-get update && apt-get install -y \\
    postgresql-client \\
    && rm -rf /var/lib/apt/lists/*

# Copiar archivo de dependencias Python
COPY requirements.txt .

# Instalar dependencias Python (sin cache para reducir tama√±o)
RUN pip install --no-cache-dir -r requirements.txt

# Copiar todo el c√≥digo de la aplicaci√≥n
COPY . .

# Comando por defecto: levantar servidor de desarrollo Django
CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]</code></pre>

      <h4>Opci√≥n B: Alpine Linux (s√∫per liviana para producci√≥n)</h4>
      <pre><code># Usar Alpine Linux (mucho m√°s liviana)
FROM python:3.11-alpine

# Establecer directorio de trabajo
WORKDIR /app

# Alpine usa 'apk' en lugar de 'apt-get'
RUN apk add --no-cache postgresql-client

# Copiar requirements e instalar dependencias Python
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copiar c√≥digo
COPY . .

# Comando por defecto
CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]</code></pre>

      <h4>üìä ¬øCu√°l elegir?</h4>
      <table>
        <thead>
          <tr>
            <th>Imagen</th>
            <th>Tama√±o</th>
            <th>Cu√°ndo usar</th>
            <th>Pros</th>
            <th>Contras</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>python:3.11-slim</code></td>
            <td>~45MB</td>
            <td>Desarrollo y proyectos complejos</td>
            <td>‚úÖ Compatibilidad total<br>‚úÖ F√°cil de usar<br>‚úÖ Bash shell</td>
            <td>‚ùå M√°s pesada</td>
          </tr>
          <tr>
            <td><code>python:3.11-alpine</code></td>
            <td>~15MB</td>
            <td>Producci√≥n y microservicios</td>
            <td>‚úÖ S√∫per liviana<br>‚úÖ M√°s segura<br>‚úÖ Ideal para deploy</td>
            <td>‚ùå Puede tener problemas con algunas librer√≠as<br>‚ùå Shell 'sh' en lugar de 'bash'</td>
          </tr>
        </tbody>
      </table>

      <blockquote>
        <p><strong>üí° Regla pr√°ctica:</strong></p>
        <p>Empez√° con <code>python:3.11-slim</code> para desarrollo. Si necesit√°s optimizar tama√±o en producci√≥n y no ten√©s problemas con las dependencias, cambi√° a <code>python:3.11-alpine</code>.</p>
      </blockquote>

      <p>Este archivo crea un entorno Python limpio con dependencias instaladas y levanta Django dentro del contenedor con tu c√≥digo.</p>

      <h3>2. Dockerfile para producci√≥n (multi-stage)</h3>
      <p>En producci√≥n, el contenedor debe ser m√°s liviano y seguro. Para eso usamos <strong>multi-stage build</strong>:</p>

      <pre><code># Etapa 1: Construcci√≥n (builder)
FROM python:3.11-slim as builder
WORKDIR /app

# Copiar requirements e instalar dependencias
COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

# Etapa 2: Producci√≥n (imagen final m√°s liviana)
FROM python:3.11-slim
WORKDIR /app

# Copiar solo las dependencias instaladas desde la etapa builder
COPY --from=builder /root/.local /root/.local

# Agregar dependencias al PATH
ENV PATH=/root/.local/bin:$PATH

# Copiar c√≥digo de la aplicaci√≥n
COPY . .

# Comando de producci√≥n: usar Gunicorn (servidor WSGI profesional)
CMD ["gunicorn", "mi_proyecto.wsgi:application", "--bind", "0.0.0.0:8000"]</code></pre>

      <h4>Beneficios del multi-stage:</h4>
      <ul>
        <li>‚úÖ Imagen m√°s chica</li>
        <li>‚úÖ M√°s r√°pida de construir</li>
        <li>‚úÖ Lista para deploy real</li>
      </ul>

      <h3>3. docker-compose.yml ‚Äì Desarrollo real con Postgres</h3>
      <pre><code>version: '3.8'

services:
  # Servicio de base de datos PostgreSQL
  db:
    image: postgres:15  # Versi√≥n espec√≠fica, no 'latest'
    environment:
      POSTGRES_DB: ventas_db      # Nombre de la base de datos
      POSTGRES_USER: postgres     # Usuario de la base de datos
      POSTGRES_PASSWORD: postgres # Contrase√±a (cambiar en producci√≥n)
    volumes:
      # Volumen persistente para que los datos no se pierdan
      - postgres_data:/var/lib/postgresql/data

  # Servicio de aplicaci√≥n Django
  web:
    build: .  # Construir desde Dockerfile local
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      # Montar c√≥digo local para desarrollo en tiempo real
      - .:/app
    ports:
      # Exponer puerto 8000 del contenedor al puerto 8000 del host
      - "8000:8000"
    depends_on:
      # Esperar a que la base de datos est√© lista
      - db
    environment:
      - DEBUG=1
      # URL de conexi√≥n a la base de datos
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/ventas_db

# Definir vol√∫menes persistentes
volumes:
  postgres_data:</code></pre>

      <h4>¬øPor qu√© funciona as√≠?</h4>
      <ul>
        <li>‚úÖ <strong>volumes</strong> garantiza que los datos no se pierdan</li>
        <li>‚úÖ <strong>depends_on</strong> hace que Django espere a Postgres</li>
        <li>‚úÖ Claridad total: backend y base de datos en 2 contenedores limpios</li>
      </ul>

      <h3>4. Variables de entorno (.env)</h3>
      <p>Nunca pongas credenciales en el c√≥digo. Us√° <code>.env</code>:</p>

      <pre><code># Base de datos
POSTGRES_DB=ventas_db
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres

# Django
SECRET_KEY=tu_clave_secreta_super_segura
DEBUG=1

# URLs
DATABASE_URL=postgresql://postgres:postgres@db:5432/ventas_db</code></pre>

      <p>Y en <code>docker-compose.yml</code>:</p>
      <pre><code>services:
  web:
    # ... otras configuraciones
    env_file:
      - .env  # Cargar variables desde archivo .env</code></pre>

      <h3>5. Health check (opcional pero profesional)</h3>
      <p>Esto permite monitorear si el contenedor est√° vivo y respondiendo:</p>

      <pre><code># En el Dockerfile
HEALTHCHECK --interval=30s --timeout=5s --retries=3 \\
  CMD curl -f http://localhost:8000/ || exit 1</code></pre>

      <h3>‚úÖ Buenas pr√°cticas finales</h3>
      <table>
        <thead>
          <tr>
            <th>Pr√°ctica</th>
            <th>¬øPor qu√©?</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Us√° im√°genes espec√≠ficas</td>
            <td>python:3.11-slim, no latest</td>
          </tr>
          <tr>
            <td>Separ√° desarrollo y producci√≥n</td>
            <td>Diferentes necesidades, diferentes configuraciones</td>
          </tr>
          <tr>
            <td>Us√° vol√∫menes para datos</td>
            <td>No perder informaci√≥n al reiniciar contenedores</td>
          </tr>
          <tr>
            <td>No metas secretos en el repo</td>
            <td>Us√° .env y gesti√≥n de secretos</td>
          </tr>
          <tr>
            <td>Contenedores simples</td>
            <td>Proyectos mantenibles y escalables</td>
          </tr>
          <tr>
            <td>Problemas comunes con Alpine</td>
            <td>Algunas librer√≠as necesitan dependencias de compilaci√≥n</td>
          </tr>
        </tbody>
      </table>

      <h4>‚ö†Ô∏è Problemas comunes con Alpine Linux</h4>
      <p>Si elegiste Alpine y ten√©s problemas con algunas librer√≠as Python, pod√©s necesitar instalar dependencias de compilaci√≥n:</p>
      
      <pre><code># Para librer√≠as que necesitan compilaci√≥n (ej: psycopg2, Pillow)
FROM python:3.11-alpine

RUN apk add --no-cache \\
    postgresql-client \\
    postgresql-dev \\
    gcc \\
    musl-dev \\
    libffi-dev

# Resto del Dockerfile...</code></pre>

      <p><strong>Librer√≠as problem√°ticas comunes:</strong></p>
      <ul>
        <li><code>psycopg2</code> (PostgreSQL adapter)</li>
        <li><code>Pillow</code> (procesamiento de im√°genes)</li>
        <li><code>cryptography</code> (encriptaci√≥n)</li>
        <li><code>lxml</code> (XML processing)</li>
      </ul>

      <h3>üöÄ Comandos √∫tiles</h3>
      <pre><code># Levantar todo el entorno
docker-compose up --build

# Levantar en segundo plano
docker-compose up -d

# Ver logs
docker-compose logs -f web

# Ejecutar comandos Django
docker-compose exec web python manage.py migrate
docker-compose exec web python manage.py createsuperuser

# Parar todo
docker-compose down

# Parar y eliminar vol√∫menes (¬°CUIDADO!)
docker-compose down -v</code></pre>

      <blockquote>
        <p><strong>üîß Regla de Docker real:</strong></p>
        <p>Docker no es solo moda: es una herramienta clave para backenders. Te permite tener entornos consistentes, facilitar despliegues y trabajar bien con bases de datos como Postgres sin instalar nada en tu m√°quina.</p>
      </blockquote>

      <h3>Conclusi√≥n</h3>
      <p>Con este setup b√°sico, ya ten√©s una base profesional para llevar tu backend a producci√≥n real sin dolores de cabeza. Docker te da la confianza de que si funciona en tu contenedor, va a funcionar en cualquier servidor.</p>
    `,
    tags: ["Docker", "Django", "PostgreSQL", "DevOps", "Backend"],
    url: "/notas/docker-backenders-setup-profesional-django-postgres"
  },
  {
    titulo: "Caso t√©cnico: Problema de indexaci√≥n en Next.js + SEO",
    fecha: "Oct 2025",
    resumen: "Estaba padeciendo un problema de SEO frustrante (ya que lejos de ser experto) me tope con un caso de indexaci√≥n fallida: Google se negaba a indexar nuestras p√°ginas de contenido din√°mico (/cabanas/[id]). El culpable era un tag canonical . As√≠ fue como, usando la Metadata API de Next.js y un poco de investigaci√≥n, logre que Google viera nuestras p√°ginas.",
    contenido: `
      <h2>Problema</h2>
      <p>Google no estaba indexando las p√°ginas din√°micas del sitio (ruta <code>/cabanas/[id]</code>). Tras investigar , y sabiendo del error de la consola donde se indicaba que el tag <code>canonical</code> en las p√°ginas apuntaba a la p√°gina √≠ndice en lugar de la URL can√≥nica individual , me di cuenta de que la configuraci√≥n del tag <code>canonical</code> era incorrecta.</p>

      <h2>Resultado</h2>
      <p>Google no indexaba p√°ginas din√°micas (<code>/cabanas/[id]</code>) por canonical incorrecto.</p>

      <h2>Soluci√≥n</h2>
      <ol>
        <li><strong>Implementaci√≥n de metadata din√°mica con la Metadata API de Next.js:</strong> a√±adimos <code>generateMetadata</code> en la p√°gina din√°mica para devolver <code>title</code>, <code>description</code> y <code>canonical</code> basados en el par√°metro <code>id</code>.</li>
        <li><strong>OpenGraph din√°mico:</strong> generamos tags <code>og:title</code>, <code>og:description</code> y <code>og:url</code> para mejorar la apariencia al compartir y la indexaci√≥n.</li>
        <li><strong>Correcci√≥n de la estructura SEO en App Router:</strong> evitamos renderizar un canonical global desde el layout que sobreescrib√≠a cada p√°gina.</li>
        <li><strong>Verificaci√≥n en Google Search Console:</strong> solicitamos reindexaci√≥n y monitorizamos cobertura ‚Äî las p√°ginas comenzaron a aparecer despu√©s del recrawl.</li>
      </ol>

      <h3>Tech</h3>
      <ul>
        <li>Next.js 14</li>
        <li>Metadata API</li>
        <li>Vercel</li>
        <li>Google Search Console</li>
      </ul>
    `,
    tags: ["Next.js", "SEO", "Metadata", "Google"],
    url: "/notas/caso-indexacion-nextjs-seo"
  }
];

export function slugifyNota(titulo: string) {
  return titulo
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "") // Remover acentos
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "");
}
